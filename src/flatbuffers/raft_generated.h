// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RAFT_RAFT_FBS_H_
#define FLATBUFFERS_GENERATED_RAFT_RAFT_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace raft {
namespace fbs {

struct server_description;

struct simple_configuration_description;

struct configuration_description;

struct request_vote;

struct vote_response;

struct log_entry;

struct append_entry;

struct append_response;

struct configuration_checkpoint;

struct append_checkpoint_chunk;

struct append_checkpoint_chunk_response;

struct client_request;

struct client_response;

struct set_configuration_request;

struct set_configuration_response;

struct raft_message;

enum log_entry_type {
  log_entry_type_COMMAND = 0,
  log_entry_type_CONFIGURATION = 1,
  log_entry_type_NOOP = 2,
  log_entry_type_MIN = log_entry_type_COMMAND,
  log_entry_type_MAX = log_entry_type_NOOP
};

inline const char **EnumNameslog_entry_type() {
  static const char *names[] = {
    "COMMAND",
    "CONFIGURATION",
    "NOOP",
    nullptr
  };
  return names;
}

inline const char *EnumNamelog_entry_type(log_entry_type e) {
  const size_t index = static_cast<int>(e);
  return EnumNameslog_entry_type()[index];
}

enum client_result {
  client_result_SUCCESS = 0,
  client_result_FAIL = 1,
  client_result_RETRY = 2,
  client_result_NOT_LEADER = 3,
  client_result_MIN = client_result_SUCCESS,
  client_result_MAX = client_result_NOT_LEADER
};

inline const char **EnumNamesclient_result() {
  static const char *names[] = {
    "SUCCESS",
    "FAIL",
    "RETRY",
    "NOT_LEADER",
    nullptr
  };
  return names;
}

inline const char *EnumNameclient_result(client_result e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesclient_result()[index];
}

enum any_message {
  any_message_NONE = 0,
  any_message_request_vote = 1,
  any_message_vote_response = 2,
  any_message_append_entry = 3,
  any_message_append_response = 4,
  any_message_MIN = any_message_NONE,
  any_message_MAX = any_message_append_response
};

inline const char **EnumNamesany_message() {
  static const char *names[] = {
    "NONE",
    "request_vote",
    "vote_response",
    "append_entry",
    "append_response",
    nullptr
  };
  return names;
}

inline const char *EnumNameany_message(any_message e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesany_message()[index];
}

template<typename T> struct any_messageTraits {
  static const any_message enum_value = any_message_NONE;
};

template<> struct any_messageTraits<request_vote> {
  static const any_message enum_value = any_message_request_vote;
};

template<> struct any_messageTraits<vote_response> {
  static const any_message enum_value = any_message_vote_response;
};

template<> struct any_messageTraits<append_entry> {
  static const any_message enum_value = any_message_append_entry;
};

template<> struct any_messageTraits<append_response> {
  static const any_message enum_value = any_message_append_response;
};

bool Verifyany_message(flatbuffers::Verifier &verifier, const void *obj, any_message type);
bool Verifyany_messageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct server_description FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_ADDRESS = 6
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           verifier.EndTable();
  }
};

struct server_descriptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(server_description::VT_ID, id, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(server_description::VT_ADDRESS, address);
  }
  server_descriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  server_descriptionBuilder &operator=(const server_descriptionBuilder &);
  flatbuffers::Offset<server_description> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<server_description>(end);
    return o;
  }
};

inline flatbuffers::Offset<server_description> Createserver_description(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0) {
  server_descriptionBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_address(address);
  return builder_.Finish();
}

inline flatbuffers::Offset<server_description> Createserver_descriptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const char *address = nullptr) {
  return Createserver_description(
      _fbb,
      id,
      address ? _fbb.CreateString(address) : 0);
}

struct simple_configuration_description FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SERVERS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<server_description>> *servers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server_description>> *>(VT_SERVERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SERVERS) &&
           verifier.Verify(servers()) &&
           verifier.VerifyVectorOfTables(servers()) &&
           verifier.EndTable();
  }
};

struct simple_configuration_descriptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_servers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server_description>>> servers) {
    fbb_.AddOffset(simple_configuration_description::VT_SERVERS, servers);
  }
  simple_configuration_descriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  simple_configuration_descriptionBuilder &operator=(const simple_configuration_descriptionBuilder &);
  flatbuffers::Offset<simple_configuration_description> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<simple_configuration_description>(end);
    return o;
  }
};

inline flatbuffers::Offset<simple_configuration_description> Createsimple_configuration_description(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server_description>>> servers = 0) {
  simple_configuration_descriptionBuilder builder_(_fbb);
  builder_.add_servers(servers);
  return builder_.Finish();
}

inline flatbuffers::Offset<simple_configuration_description> Createsimple_configuration_descriptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<server_description>> *servers = nullptr) {
  return Createsimple_configuration_description(
      _fbb,
      servers ? _fbb.CreateVector<flatbuffers::Offset<server_description>>(*servers) : 0);
}

struct configuration_description FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FROM = 4,
    VT_TO = 6
  };
  const simple_configuration_description *from() const {
    return GetPointer<const simple_configuration_description *>(VT_FROM);
  }
  const simple_configuration_description *to() const {
    return GetPointer<const simple_configuration_description *>(VT_TO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FROM) &&
           verifier.VerifyTable(from()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TO) &&
           verifier.VerifyTable(to()) &&
           verifier.EndTable();
  }
};

struct configuration_descriptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_from(flatbuffers::Offset<simple_configuration_description> from) {
    fbb_.AddOffset(configuration_description::VT_FROM, from);
  }
  void add_to(flatbuffers::Offset<simple_configuration_description> to) {
    fbb_.AddOffset(configuration_description::VT_TO, to);
  }
  configuration_descriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  configuration_descriptionBuilder &operator=(const configuration_descriptionBuilder &);
  flatbuffers::Offset<configuration_description> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<configuration_description>(end);
    return o;
  }
};

inline flatbuffers::Offset<configuration_description> Createconfiguration_description(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<simple_configuration_description> from = 0,
    flatbuffers::Offset<simple_configuration_description> to = 0) {
  configuration_descriptionBuilder builder_(_fbb);
  builder_.add_to(to);
  builder_.add_from(from);
  return builder_.Finish();
}

struct request_vote FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECIPIENT_ID = 4,
    VT_TERM_NUMBER = 6,
    VT_CANDIDATE_ID = 8,
    VT_LAST_LOG_INDEX = 10,
    VT_LAST_LOG_TERM = 12
  };
  uint64_t recipient_id() const {
    return GetField<uint64_t>(VT_RECIPIENT_ID, 0);
  }
  uint64_t term_number() const {
    return GetField<uint64_t>(VT_TERM_NUMBER, 0);
  }
  uint64_t candidate_id() const {
    return GetField<uint64_t>(VT_CANDIDATE_ID, 0);
  }
  uint64_t last_log_index() const {
    return GetField<uint64_t>(VT_LAST_LOG_INDEX, 0);
  }
  uint64_t last_log_term() const {
    return GetField<uint64_t>(VT_LAST_LOG_TERM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_RECIPIENT_ID) &&
           VerifyField<uint64_t>(verifier, VT_TERM_NUMBER) &&
           VerifyField<uint64_t>(verifier, VT_CANDIDATE_ID) &&
           VerifyField<uint64_t>(verifier, VT_LAST_LOG_INDEX) &&
           VerifyField<uint64_t>(verifier, VT_LAST_LOG_TERM) &&
           verifier.EndTable();
  }
};

struct request_voteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_recipient_id(uint64_t recipient_id) {
    fbb_.AddElement<uint64_t>(request_vote::VT_RECIPIENT_ID, recipient_id, 0);
  }
  void add_term_number(uint64_t term_number) {
    fbb_.AddElement<uint64_t>(request_vote::VT_TERM_NUMBER, term_number, 0);
  }
  void add_candidate_id(uint64_t candidate_id) {
    fbb_.AddElement<uint64_t>(request_vote::VT_CANDIDATE_ID, candidate_id, 0);
  }
  void add_last_log_index(uint64_t last_log_index) {
    fbb_.AddElement<uint64_t>(request_vote::VT_LAST_LOG_INDEX, last_log_index, 0);
  }
  void add_last_log_term(uint64_t last_log_term) {
    fbb_.AddElement<uint64_t>(request_vote::VT_LAST_LOG_TERM, last_log_term, 0);
  }
  request_voteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  request_voteBuilder &operator=(const request_voteBuilder &);
  flatbuffers::Offset<request_vote> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<request_vote>(end);
    return o;
  }
};

inline flatbuffers::Offset<request_vote> Createrequest_vote(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t recipient_id = 0,
    uint64_t term_number = 0,
    uint64_t candidate_id = 0,
    uint64_t last_log_index = 0,
    uint64_t last_log_term = 0) {
  request_voteBuilder builder_(_fbb);
  builder_.add_last_log_term(last_log_term);
  builder_.add_last_log_index(last_log_index);
  builder_.add_candidate_id(candidate_id);
  builder_.add_term_number(term_number);
  builder_.add_recipient_id(recipient_id);
  return builder_.Finish();
}

struct vote_response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEER_ID = 4,
    VT_TERM_NUMBER = 6,
    VT_REQUEST_TERM_NUMBER = 8,
    VT_GRANTED = 10
  };
  uint64_t peer_id() const {
    return GetField<uint64_t>(VT_PEER_ID, 0);
  }
  uint64_t term_number() const {
    return GetField<uint64_t>(VT_TERM_NUMBER, 0);
  }
  uint64_t request_term_number() const {
    return GetField<uint64_t>(VT_REQUEST_TERM_NUMBER, 0);
  }
  bool granted() const {
    return GetField<uint8_t>(VT_GRANTED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PEER_ID) &&
           VerifyField<uint64_t>(verifier, VT_TERM_NUMBER) &&
           VerifyField<uint64_t>(verifier, VT_REQUEST_TERM_NUMBER) &&
           VerifyField<uint8_t>(verifier, VT_GRANTED) &&
           verifier.EndTable();
  }
};

struct vote_responseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peer_id(uint64_t peer_id) {
    fbb_.AddElement<uint64_t>(vote_response::VT_PEER_ID, peer_id, 0);
  }
  void add_term_number(uint64_t term_number) {
    fbb_.AddElement<uint64_t>(vote_response::VT_TERM_NUMBER, term_number, 0);
  }
  void add_request_term_number(uint64_t request_term_number) {
    fbb_.AddElement<uint64_t>(vote_response::VT_REQUEST_TERM_NUMBER, request_term_number, 0);
  }
  void add_granted(bool granted) {
    fbb_.AddElement<uint8_t>(vote_response::VT_GRANTED, static_cast<uint8_t>(granted), 0);
  }
  vote_responseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  vote_responseBuilder &operator=(const vote_responseBuilder &);
  flatbuffers::Offset<vote_response> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<vote_response>(end);
    return o;
  }
};

inline flatbuffers::Offset<vote_response> Createvote_response(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t peer_id = 0,
    uint64_t term_number = 0,
    uint64_t request_term_number = 0,
    bool granted = false) {
  vote_responseBuilder builder_(_fbb);
  builder_.add_request_term_number(request_term_number);
  builder_.add_term_number(term_number);
  builder_.add_peer_id(peer_id);
  builder_.add_granted(granted);
  return builder_.Finish();
}

struct log_entry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_TERM = 6,
    VT_DATA = 8,
    VT_CONFIGURATION = 10
  };
  log_entry_type type() const {
    return static_cast<log_entry_type>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint64_t term() const {
    return GetField<uint64_t>(VT_TERM, 0);
  }
  const flatbuffers::String *data() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA);
  }
  const configuration_description *configuration() const {
    return GetPointer<const configuration_description *>(VT_CONFIGURATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint64_t>(verifier, VT_TERM) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CONFIGURATION) &&
           verifier.VerifyTable(configuration()) &&
           verifier.EndTable();
  }
};

struct log_entryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(log_entry_type type) {
    fbb_.AddElement<int8_t>(log_entry::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_term(uint64_t term) {
    fbb_.AddElement<uint64_t>(log_entry::VT_TERM, term, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::String> data) {
    fbb_.AddOffset(log_entry::VT_DATA, data);
  }
  void add_configuration(flatbuffers::Offset<configuration_description> configuration) {
    fbb_.AddOffset(log_entry::VT_CONFIGURATION, configuration);
  }
  log_entryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  log_entryBuilder &operator=(const log_entryBuilder &);
  flatbuffers::Offset<log_entry> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<log_entry>(end);
    return o;
  }
};

inline flatbuffers::Offset<log_entry> Createlog_entry(
    flatbuffers::FlatBufferBuilder &_fbb,
    log_entry_type type = log_entry_type_COMMAND,
    uint64_t term = 0,
    flatbuffers::Offset<flatbuffers::String> data = 0,
    flatbuffers::Offset<configuration_description> configuration = 0) {
  log_entryBuilder builder_(_fbb);
  builder_.add_term(term);
  builder_.add_configuration(configuration);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<log_entry> Createlog_entryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    log_entry_type type = log_entry_type_COMMAND,
    uint64_t term = 0,
    const char *data = nullptr,
    flatbuffers::Offset<configuration_description> configuration = 0) {
  return Createlog_entry(
      _fbb,
      type,
      term,
      data ? _fbb.CreateString(data) : 0,
      configuration);
}

struct append_entry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECIPIENT_ID = 4,
    VT_TERM_NUMBER = 6,
    VT_LEADER_ID = 8,
    VT_PREVIOUS_LOG_INDEX = 10,
    VT_PREVIOUS_LOG_TERM = 12,
    VT_LEADER_COMMIT_INDEX = 14,
    VT_ENTRY = 16
  };
  uint64_t recipient_id() const {
    return GetField<uint64_t>(VT_RECIPIENT_ID, 0);
  }
  uint64_t term_number() const {
    return GetField<uint64_t>(VT_TERM_NUMBER, 0);
  }
  uint64_t leader_id() const {
    return GetField<uint64_t>(VT_LEADER_ID, 0);
  }
  uint64_t previous_log_index() const {
    return GetField<uint64_t>(VT_PREVIOUS_LOG_INDEX, 0);
  }
  uint64_t previous_log_term() const {
    return GetField<uint64_t>(VT_PREVIOUS_LOG_TERM, 0);
  }
  uint64_t leader_commit_index() const {
    return GetField<uint64_t>(VT_LEADER_COMMIT_INDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<log_entry>> *entry() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<log_entry>> *>(VT_ENTRY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_RECIPIENT_ID) &&
           VerifyField<uint64_t>(verifier, VT_TERM_NUMBER) &&
           VerifyField<uint64_t>(verifier, VT_LEADER_ID) &&
           VerifyField<uint64_t>(verifier, VT_PREVIOUS_LOG_INDEX) &&
           VerifyField<uint64_t>(verifier, VT_PREVIOUS_LOG_TERM) &&
           VerifyField<uint64_t>(verifier, VT_LEADER_COMMIT_INDEX) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ENTRY) &&
           verifier.Verify(entry()) &&
           verifier.VerifyVectorOfTables(entry()) &&
           verifier.EndTable();
  }
};

struct append_entryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_recipient_id(uint64_t recipient_id) {
    fbb_.AddElement<uint64_t>(append_entry::VT_RECIPIENT_ID, recipient_id, 0);
  }
  void add_term_number(uint64_t term_number) {
    fbb_.AddElement<uint64_t>(append_entry::VT_TERM_NUMBER, term_number, 0);
  }
  void add_leader_id(uint64_t leader_id) {
    fbb_.AddElement<uint64_t>(append_entry::VT_LEADER_ID, leader_id, 0);
  }
  void add_previous_log_index(uint64_t previous_log_index) {
    fbb_.AddElement<uint64_t>(append_entry::VT_PREVIOUS_LOG_INDEX, previous_log_index, 0);
  }
  void add_previous_log_term(uint64_t previous_log_term) {
    fbb_.AddElement<uint64_t>(append_entry::VT_PREVIOUS_LOG_TERM, previous_log_term, 0);
  }
  void add_leader_commit_index(uint64_t leader_commit_index) {
    fbb_.AddElement<uint64_t>(append_entry::VT_LEADER_COMMIT_INDEX, leader_commit_index, 0);
  }
  void add_entry(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<log_entry>>> entry) {
    fbb_.AddOffset(append_entry::VT_ENTRY, entry);
  }
  append_entryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  append_entryBuilder &operator=(const append_entryBuilder &);
  flatbuffers::Offset<append_entry> Finish() {
    const auto end = fbb_.EndTable(start_, 7);
    auto o = flatbuffers::Offset<append_entry>(end);
    return o;
  }
};

inline flatbuffers::Offset<append_entry> Createappend_entry(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t recipient_id = 0,
    uint64_t term_number = 0,
    uint64_t leader_id = 0,
    uint64_t previous_log_index = 0,
    uint64_t previous_log_term = 0,
    uint64_t leader_commit_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<log_entry>>> entry = 0) {
  append_entryBuilder builder_(_fbb);
  builder_.add_leader_commit_index(leader_commit_index);
  builder_.add_previous_log_term(previous_log_term);
  builder_.add_previous_log_index(previous_log_index);
  builder_.add_leader_id(leader_id);
  builder_.add_term_number(term_number);
  builder_.add_recipient_id(recipient_id);
  builder_.add_entry(entry);
  return builder_.Finish();
}

inline flatbuffers::Offset<append_entry> Createappend_entryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t recipient_id = 0,
    uint64_t term_number = 0,
    uint64_t leader_id = 0,
    uint64_t previous_log_index = 0,
    uint64_t previous_log_term = 0,
    uint64_t leader_commit_index = 0,
    const std::vector<flatbuffers::Offset<log_entry>> *entry = nullptr) {
  return Createappend_entry(
      _fbb,
      recipient_id,
      term_number,
      leader_id,
      previous_log_index,
      previous_log_term,
      leader_commit_index,
      entry ? _fbb.CreateVector<flatbuffers::Offset<log_entry>>(*entry) : 0);
}

struct append_response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECIPIENT_ID = 4,
    VT_TERM_NUMBER = 6,
    VT_REQUEST_TERM_NUMBER = 8,
    VT_BEGIN_INDEX = 10,
    VT_LAST_INDEX = 12,
    VT_SUCCESS = 14
  };
  uint64_t recipient_id() const {
    return GetField<uint64_t>(VT_RECIPIENT_ID, 0);
  }
  uint64_t term_number() const {
    return GetField<uint64_t>(VT_TERM_NUMBER, 0);
  }
  uint64_t request_term_number() const {
    return GetField<uint64_t>(VT_REQUEST_TERM_NUMBER, 0);
  }
  uint64_t begin_index() const {
    return GetField<uint64_t>(VT_BEGIN_INDEX, 0);
  }
  uint64_t last_index() const {
    return GetField<uint64_t>(VT_LAST_INDEX, 0);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_RECIPIENT_ID) &&
           VerifyField<uint64_t>(verifier, VT_TERM_NUMBER) &&
           VerifyField<uint64_t>(verifier, VT_REQUEST_TERM_NUMBER) &&
           VerifyField<uint64_t>(verifier, VT_BEGIN_INDEX) &&
           VerifyField<uint64_t>(verifier, VT_LAST_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct append_responseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_recipient_id(uint64_t recipient_id) {
    fbb_.AddElement<uint64_t>(append_response::VT_RECIPIENT_ID, recipient_id, 0);
  }
  void add_term_number(uint64_t term_number) {
    fbb_.AddElement<uint64_t>(append_response::VT_TERM_NUMBER, term_number, 0);
  }
  void add_request_term_number(uint64_t request_term_number) {
    fbb_.AddElement<uint64_t>(append_response::VT_REQUEST_TERM_NUMBER, request_term_number, 0);
  }
  void add_begin_index(uint64_t begin_index) {
    fbb_.AddElement<uint64_t>(append_response::VT_BEGIN_INDEX, begin_index, 0);
  }
  void add_last_index(uint64_t last_index) {
    fbb_.AddElement<uint64_t>(append_response::VT_LAST_INDEX, last_index, 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(append_response::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  append_responseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  append_responseBuilder &operator=(const append_responseBuilder &);
  flatbuffers::Offset<append_response> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<append_response>(end);
    return o;
  }
};

inline flatbuffers::Offset<append_response> Createappend_response(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t recipient_id = 0,
    uint64_t term_number = 0,
    uint64_t request_term_number = 0,
    uint64_t begin_index = 0,
    uint64_t last_index = 0,
    bool success = false) {
  append_responseBuilder builder_(_fbb);
  builder_.add_last_index(last_index);
  builder_.add_begin_index(begin_index);
  builder_.add_request_term_number(request_term_number);
  builder_.add_term_number(term_number);
  builder_.add_recipient_id(recipient_id);
  builder_.add_success(success);
  return builder_.Finish();
}

struct configuration_checkpoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INDEX = 4,
    VT_DESCRIPTION = 6
  };
  uint64_t index() const {
    return GetField<uint64_t>(VT_INDEX, 0);
  }
  const configuration_description *description() const {
    return GetPointer<const configuration_description *>(VT_DESCRIPTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_INDEX) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DESCRIPTION) &&
           verifier.VerifyTable(description()) &&
           verifier.EndTable();
  }
};

struct configuration_checkpointBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(uint64_t index) {
    fbb_.AddElement<uint64_t>(configuration_checkpoint::VT_INDEX, index, 0);
  }
  void add_description(flatbuffers::Offset<configuration_description> description) {
    fbb_.AddOffset(configuration_checkpoint::VT_DESCRIPTION, description);
  }
  configuration_checkpointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  configuration_checkpointBuilder &operator=(const configuration_checkpointBuilder &);
  flatbuffers::Offset<configuration_checkpoint> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<configuration_checkpoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<configuration_checkpoint> Createconfiguration_checkpoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t index = 0,
    flatbuffers::Offset<configuration_description> description = 0) {
  configuration_checkpointBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_description(description);
  return builder_.Finish();
}

struct append_checkpoint_chunk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECIPIENT_ID = 4,
    VT_TERM_NUMBER = 6,
    VT_LEADER_ID = 8,
    VT_LAST_CHECKPOINT_INDEX = 10,
    VT_LAST_CHECKPOINT_TERM = 12,
    VT_LAST_CHECKPOINT_CONFIGURATION = 14,
    VT_CHECKPOINT_BEGIN = 16,
    VT_CHECKPOINT_END = 18,
    VT_CHECKPOINT_DONE = 20,
    VT_DATA = 22
  };
  uint64_t recipient_id() const {
    return GetField<uint64_t>(VT_RECIPIENT_ID, 0);
  }
  uint64_t term_number() const {
    return GetField<uint64_t>(VT_TERM_NUMBER, 0);
  }
  uint64_t leader_id() const {
    return GetField<uint64_t>(VT_LEADER_ID, 0);
  }
  uint64_t last_checkpoint_index() const {
    return GetField<uint64_t>(VT_LAST_CHECKPOINT_INDEX, 0);
  }
  uint64_t last_checkpoint_term() const {
    return GetField<uint64_t>(VT_LAST_CHECKPOINT_TERM, 0);
  }
  const configuration_checkpoint *last_checkpoint_configuration() const {
    return GetPointer<const configuration_checkpoint *>(VT_LAST_CHECKPOINT_CONFIGURATION);
  }
  uint64_t checkpoint_begin() const {
    return GetField<uint64_t>(VT_CHECKPOINT_BEGIN, 0);
  }
  uint64_t checkpoint_end() const {
    return GetField<uint64_t>(VT_CHECKPOINT_END, 0);
  }
  bool checkpoint_done() const {
    return GetField<uint8_t>(VT_CHECKPOINT_DONE, 0) != 0;
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_RECIPIENT_ID) &&
           VerifyField<uint64_t>(verifier, VT_TERM_NUMBER) &&
           VerifyField<uint64_t>(verifier, VT_LEADER_ID) &&
           VerifyField<uint64_t>(verifier, VT_LAST_CHECKPOINT_INDEX) &&
           VerifyField<uint64_t>(verifier, VT_LAST_CHECKPOINT_TERM) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LAST_CHECKPOINT_CONFIGURATION) &&
           verifier.VerifyTable(last_checkpoint_configuration()) &&
           VerifyField<uint64_t>(verifier, VT_CHECKPOINT_BEGIN) &&
           VerifyField<uint64_t>(verifier, VT_CHECKPOINT_END) &&
           VerifyField<uint8_t>(verifier, VT_CHECKPOINT_DONE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct append_checkpoint_chunkBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_recipient_id(uint64_t recipient_id) {
    fbb_.AddElement<uint64_t>(append_checkpoint_chunk::VT_RECIPIENT_ID, recipient_id, 0);
  }
  void add_term_number(uint64_t term_number) {
    fbb_.AddElement<uint64_t>(append_checkpoint_chunk::VT_TERM_NUMBER, term_number, 0);
  }
  void add_leader_id(uint64_t leader_id) {
    fbb_.AddElement<uint64_t>(append_checkpoint_chunk::VT_LEADER_ID, leader_id, 0);
  }
  void add_last_checkpoint_index(uint64_t last_checkpoint_index) {
    fbb_.AddElement<uint64_t>(append_checkpoint_chunk::VT_LAST_CHECKPOINT_INDEX, last_checkpoint_index, 0);
  }
  void add_last_checkpoint_term(uint64_t last_checkpoint_term) {
    fbb_.AddElement<uint64_t>(append_checkpoint_chunk::VT_LAST_CHECKPOINT_TERM, last_checkpoint_term, 0);
  }
  void add_last_checkpoint_configuration(flatbuffers::Offset<configuration_checkpoint> last_checkpoint_configuration) {
    fbb_.AddOffset(append_checkpoint_chunk::VT_LAST_CHECKPOINT_CONFIGURATION, last_checkpoint_configuration);
  }
  void add_checkpoint_begin(uint64_t checkpoint_begin) {
    fbb_.AddElement<uint64_t>(append_checkpoint_chunk::VT_CHECKPOINT_BEGIN, checkpoint_begin, 0);
  }
  void add_checkpoint_end(uint64_t checkpoint_end) {
    fbb_.AddElement<uint64_t>(append_checkpoint_chunk::VT_CHECKPOINT_END, checkpoint_end, 0);
  }
  void add_checkpoint_done(bool checkpoint_done) {
    fbb_.AddElement<uint8_t>(append_checkpoint_chunk::VT_CHECKPOINT_DONE, static_cast<uint8_t>(checkpoint_done), 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(append_checkpoint_chunk::VT_DATA, data);
  }
  append_checkpoint_chunkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  append_checkpoint_chunkBuilder &operator=(const append_checkpoint_chunkBuilder &);
  flatbuffers::Offset<append_checkpoint_chunk> Finish() {
    const auto end = fbb_.EndTable(start_, 10);
    auto o = flatbuffers::Offset<append_checkpoint_chunk>(end);
    return o;
  }
};

inline flatbuffers::Offset<append_checkpoint_chunk> Createappend_checkpoint_chunk(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t recipient_id = 0,
    uint64_t term_number = 0,
    uint64_t leader_id = 0,
    uint64_t last_checkpoint_index = 0,
    uint64_t last_checkpoint_term = 0,
    flatbuffers::Offset<configuration_checkpoint> last_checkpoint_configuration = 0,
    uint64_t checkpoint_begin = 0,
    uint64_t checkpoint_end = 0,
    bool checkpoint_done = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  append_checkpoint_chunkBuilder builder_(_fbb);
  builder_.add_checkpoint_end(checkpoint_end);
  builder_.add_checkpoint_begin(checkpoint_begin);
  builder_.add_last_checkpoint_term(last_checkpoint_term);
  builder_.add_last_checkpoint_index(last_checkpoint_index);
  builder_.add_leader_id(leader_id);
  builder_.add_term_number(term_number);
  builder_.add_recipient_id(recipient_id);
  builder_.add_data(data);
  builder_.add_last_checkpoint_configuration(last_checkpoint_configuration);
  builder_.add_checkpoint_done(checkpoint_done);
  return builder_.Finish();
}

inline flatbuffers::Offset<append_checkpoint_chunk> Createappend_checkpoint_chunkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t recipient_id = 0,
    uint64_t term_number = 0,
    uint64_t leader_id = 0,
    uint64_t last_checkpoint_index = 0,
    uint64_t last_checkpoint_term = 0,
    flatbuffers::Offset<configuration_checkpoint> last_checkpoint_configuration = 0,
    uint64_t checkpoint_begin = 0,
    uint64_t checkpoint_end = 0,
    bool checkpoint_done = false,
    const std::vector<uint8_t> *data = nullptr) {
  return Createappend_checkpoint_chunk(
      _fbb,
      recipient_id,
      term_number,
      leader_id,
      last_checkpoint_index,
      last_checkpoint_term,
      last_checkpoint_configuration,
      checkpoint_begin,
      checkpoint_end,
      checkpoint_done,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

struct append_checkpoint_chunk_response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECIPIENT_ID = 4,
    VT_TERM_NUMBER = 6,
    VT_REQUEST_TERM_NUMBER = 8,
    VT_BYTES_STORED = 10
  };
  uint64_t recipient_id() const {
    return GetField<uint64_t>(VT_RECIPIENT_ID, 0);
  }
  uint64_t term_number() const {
    return GetField<uint64_t>(VT_TERM_NUMBER, 0);
  }
  uint64_t request_term_number() const {
    return GetField<uint64_t>(VT_REQUEST_TERM_NUMBER, 0);
  }
  uint64_t bytes_stored() const {
    return GetField<uint64_t>(VT_BYTES_STORED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_RECIPIENT_ID) &&
           VerifyField<uint64_t>(verifier, VT_TERM_NUMBER) &&
           VerifyField<uint64_t>(verifier, VT_REQUEST_TERM_NUMBER) &&
           VerifyField<uint64_t>(verifier, VT_BYTES_STORED) &&
           verifier.EndTable();
  }
};

struct append_checkpoint_chunk_responseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_recipient_id(uint64_t recipient_id) {
    fbb_.AddElement<uint64_t>(append_checkpoint_chunk_response::VT_RECIPIENT_ID, recipient_id, 0);
  }
  void add_term_number(uint64_t term_number) {
    fbb_.AddElement<uint64_t>(append_checkpoint_chunk_response::VT_TERM_NUMBER, term_number, 0);
  }
  void add_request_term_number(uint64_t request_term_number) {
    fbb_.AddElement<uint64_t>(append_checkpoint_chunk_response::VT_REQUEST_TERM_NUMBER, request_term_number, 0);
  }
  void add_bytes_stored(uint64_t bytes_stored) {
    fbb_.AddElement<uint64_t>(append_checkpoint_chunk_response::VT_BYTES_STORED, bytes_stored, 0);
  }
  append_checkpoint_chunk_responseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  append_checkpoint_chunk_responseBuilder &operator=(const append_checkpoint_chunk_responseBuilder &);
  flatbuffers::Offset<append_checkpoint_chunk_response> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<append_checkpoint_chunk_response>(end);
    return o;
  }
};

inline flatbuffers::Offset<append_checkpoint_chunk_response> Createappend_checkpoint_chunk_response(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t recipient_id = 0,
    uint64_t term_number = 0,
    uint64_t request_term_number = 0,
    uint64_t bytes_stored = 0) {
  append_checkpoint_chunk_responseBuilder builder_(_fbb);
  builder_.add_bytes_stored(bytes_stored);
  builder_.add_request_term_number(request_term_number);
  builder_.add_term_number(term_number);
  builder_.add_recipient_id(recipient_id);
  return builder_.Finish();
}

struct client_request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_COMMAND = 6
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  const flatbuffers::String *command() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMAND);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMMAND) &&
           verifier.Verify(command()) &&
           verifier.EndTable();
  }
};

struct client_requestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(client_request::VT_ID, id, 0);
  }
  void add_command(flatbuffers::Offset<flatbuffers::String> command) {
    fbb_.AddOffset(client_request::VT_COMMAND, command);
  }
  client_requestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  client_requestBuilder &operator=(const client_requestBuilder &);
  flatbuffers::Offset<client_request> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<client_request>(end);
    return o;
  }
};

inline flatbuffers::Offset<client_request> Createclient_request(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    flatbuffers::Offset<flatbuffers::String> command = 0) {
  client_requestBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_command(command);
  return builder_.Finish();
}

inline flatbuffers::Offset<client_request> Createclient_requestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const char *command = nullptr) {
  return Createclient_request(
      _fbb,
      id,
      command ? _fbb.CreateString(command) : 0);
}

struct client_response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_RESULT = 6,
    VT_INDEX = 8,
    VT_LEADER_ID = 10
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  client_result result() const {
    return static_cast<client_result>(GetField<int8_t>(VT_RESULT, 0));
  }
  uint64_t index() const {
    return GetField<uint64_t>(VT_INDEX, 0);
  }
  uint64_t leader_id() const {
    return GetField<uint64_t>(VT_LEADER_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<int8_t>(verifier, VT_RESULT) &&
           VerifyField<uint64_t>(verifier, VT_INDEX) &&
           VerifyField<uint64_t>(verifier, VT_LEADER_ID) &&
           verifier.EndTable();
  }
};

struct client_responseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(client_response::VT_ID, id, 0);
  }
  void add_result(client_result result) {
    fbb_.AddElement<int8_t>(client_response::VT_RESULT, static_cast<int8_t>(result), 0);
  }
  void add_index(uint64_t index) {
    fbb_.AddElement<uint64_t>(client_response::VT_INDEX, index, 0);
  }
  void add_leader_id(uint64_t leader_id) {
    fbb_.AddElement<uint64_t>(client_response::VT_LEADER_ID, leader_id, 0);
  }
  client_responseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  client_responseBuilder &operator=(const client_responseBuilder &);
  flatbuffers::Offset<client_response> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<client_response>(end);
    return o;
  }
};

inline flatbuffers::Offset<client_response> Createclient_response(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    client_result result = client_result_SUCCESS,
    uint64_t index = 0,
    uint64_t leader_id = 0) {
  client_responseBuilder builder_(_fbb);
  builder_.add_leader_id(leader_id);
  builder_.add_index(index);
  builder_.add_id(id);
  builder_.add_result(result);
  return builder_.Finish();
}

struct set_configuration_request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OLD_ID = 4,
    VT_NEW_CONFIGURATION = 6
  };
  uint64_t old_id() const {
    return GetField<uint64_t>(VT_OLD_ID, 0);
  }
  const simple_configuration_description *new_configuration() const {
    return GetPointer<const simple_configuration_description *>(VT_NEW_CONFIGURATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_OLD_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NEW_CONFIGURATION) &&
           verifier.VerifyTable(new_configuration()) &&
           verifier.EndTable();
  }
};

struct set_configuration_requestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_old_id(uint64_t old_id) {
    fbb_.AddElement<uint64_t>(set_configuration_request::VT_OLD_ID, old_id, 0);
  }
  void add_new_configuration(flatbuffers::Offset<simple_configuration_description> new_configuration) {
    fbb_.AddOffset(set_configuration_request::VT_NEW_CONFIGURATION, new_configuration);
  }
  set_configuration_requestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  set_configuration_requestBuilder &operator=(const set_configuration_requestBuilder &);
  flatbuffers::Offset<set_configuration_request> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<set_configuration_request>(end);
    return o;
  }
};

inline flatbuffers::Offset<set_configuration_request> Createset_configuration_request(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t old_id = 0,
    flatbuffers::Offset<simple_configuration_description> new_configuration = 0) {
  set_configuration_requestBuilder builder_(_fbb);
  builder_.add_old_id(old_id);
  builder_.add_new_configuration(new_configuration);
  return builder_.Finish();
}

struct set_configuration_response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_BAD_SERVERS = 6
  };
  client_result result() const {
    return static_cast<client_result>(GetField<int8_t>(VT_RESULT, 0));
  }
  const simple_configuration_description *bad_servers() const {
    return GetPointer<const simple_configuration_description *>(VT_BAD_SERVERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_RESULT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BAD_SERVERS) &&
           verifier.VerifyTable(bad_servers()) &&
           verifier.EndTable();
  }
};

struct set_configuration_responseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(client_result result) {
    fbb_.AddElement<int8_t>(set_configuration_response::VT_RESULT, static_cast<int8_t>(result), 0);
  }
  void add_bad_servers(flatbuffers::Offset<simple_configuration_description> bad_servers) {
    fbb_.AddOffset(set_configuration_response::VT_BAD_SERVERS, bad_servers);
  }
  set_configuration_responseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  set_configuration_responseBuilder &operator=(const set_configuration_responseBuilder &);
  flatbuffers::Offset<set_configuration_response> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<set_configuration_response>(end);
    return o;
  }
};

inline flatbuffers::Offset<set_configuration_response> Createset_configuration_response(
    flatbuffers::FlatBufferBuilder &_fbb,
    client_result result = client_result_SUCCESS,
    flatbuffers::Offset<simple_configuration_description> bad_servers = 0) {
  set_configuration_responseBuilder builder_(_fbb);
  builder_.add_bad_servers(bad_servers);
  builder_.add_result(result);
  return builder_.Finish();
}

struct raft_message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  any_message message_type() const {
    return static_cast<any_message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           Verifyany_message(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

struct raft_messageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(any_message message_type) {
    fbb_.AddElement<uint8_t>(raft_message::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(raft_message::VT_MESSAGE, message);
  }
  raft_messageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  raft_messageBuilder &operator=(const raft_messageBuilder &);
  flatbuffers::Offset<raft_message> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<raft_message>(end);
    return o;
  }
};

inline flatbuffers::Offset<raft_message> Createraft_message(
    flatbuffers::FlatBufferBuilder &_fbb,
    any_message message_type = any_message_NONE,
    flatbuffers::Offset<void> message = 0) {
  raft_messageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool Verifyany_message(flatbuffers::Verifier &verifier, const void *obj, any_message type) {
  switch (type) {
    case any_message_NONE: {
      return true;
    }
    case any_message_request_vote: {
      auto ptr = reinterpret_cast<const request_vote *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case any_message_vote_response: {
      auto ptr = reinterpret_cast<const vote_response *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case any_message_append_entry: {
      auto ptr = reinterpret_cast<const append_entry *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case any_message_append_response: {
      auto ptr = reinterpret_cast<const append_response *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool Verifyany_messageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!Verifyany_message(
        verifier,  values->Get(i), types->GetEnum<any_message>(i))) {
      return false;
    }
  }
  return true;
}

inline const raft::fbs::raft_message *Getraft_message(const void *buf) {
  return flatbuffers::GetRoot<raft::fbs::raft_message>(buf);
}

inline bool Verifyraft_messageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<raft::fbs::raft_message>(nullptr);
}

inline void Finishraft_messageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<raft::fbs::raft_message> root) {
  fbb.Finish(root);
}

}  // namespace fbs
}  // namespace raft

#endif  // FLATBUFFERS_GENERATED_RAFT_RAFT_FBS_H_
